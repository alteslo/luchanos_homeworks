"""
1. Напишите функцию search_substr(subst, st), которая принимает 2 строки и определяет, имеется ли подстрока subst
в строке st. В случае нахождения подстроки, возвращается фраза «Есть контакт!», а иначе «Мимо!».
Должно быть найдено совпадение независимо от регистра обеих строк.

2. На основании предоставленного отрывка текста определить 3 наиболее часто встречаемых символа в ней.
Пробелы нужно игнорировать (не учитывать при подсчете).
Для выведения результатов вычислений требуется написать функцию top3(st).
Итог работы функции представить в виде строки: «символ – количество раз, символ – количество раз…».

2. Николай решил вспомнить старые времена.
В свое время было модно писать сообщения с чередующимися заглавной и малой буквами.
Он захотел изобрести функцию, которая будет делать с любой предоставленной строкой аналогичное.
Ваша задача: повторить труд студента camel(st) с учетом того, что пробелы и знаки препинания не должны портить
чередование регистра символов (они в этом процессе не учитываются, но возвращаются в итоговой строке).

Вопросы на проработку:
- знать какой тип можно привести к какому и что получится в результате. Выборка типов: int, bool, str, bytes, float +
типы коллекций: list, set, tuple, frozenset, bool.
- Читать Грокаем алгоритмы про: хэшмап, связный список, список (массив), множество. Сложности поиска, извлечения и
вставок элементов в каждую из этих коллекций.
"""

# типы данных
# ИЗМЕНЯЕМЫЕ и НЕИЗМЕНЯЕМЫЕ

# Кортеж, строка, frozenset

# s_1 = "test_string"
# s_1_cap = s_1.capitalize()
# print(s_1_cap, id(s_1_cap))
# print(s_1, id(s_1))

# s = "a"
# s1 = "b"
# s2 = "c"
# print(s * 10)
# s3 = s + s1 + s2
# print(s3)

# альтернатива - форматирование строк
# s3_f = f"{s}{s1}{s2}"
# s3_f_1 = "{}{}{}".format(s, s1, s2)
# s3_f_2 = "{2}{1}{0}".format(s, s1, s2)
# print(s3_f_2)
# price = "10"
# description = "Панкейки"
# s3_f_3 = "Цена: %s, наименование: %s" % (price, description)
# print(s3_f_3)

# примитивы
# int, bool, str, bytes, float
# print(2 - True)

# t = (True, "test_string", 3.14, 4, b"byte string")
# print(1 in t)
# print(1 is True)  # проверка на равенство по участку памяти, где лежат объекты
# print(1 == True)  # проверка на равенство по значению

# for el in t:
#     # print("Приведение к булеву типу: ", bool(el)) # сработало
#     # print("Приведение к int типу: ", int(el)) # не все сработало
#     # print("Приведение к str типу: ", str(el))  # сработало
#     # print("Приведение к bytes типу: ", bytes(el))  # не всё сработало
#     print("Приведение к float типу: ", float(el))  # не всё сработало

# КОЛЛЕКЦИИ
# универсальный алгоритм составления определения коллекции: <ИЗМЕНЯЕМАЯ ЛИ?> <УПОРЯДОЧЕННАЯ ЛИ?> КОЛЛЕКЦИЯ
# <УНИКАЛЬНЫХ ЛИ?> ЭЛЕМЕНТОВ <ПРОИЗВОЛЬНОГО ЛИ ТИПА?>
# уникальность - может ли в коллекции быть 2 одинаковых элемента
# Кортеж - неизменяемая упорядоченная коллекция не обязательно уникальных элементов произвольного типа.
# t = (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
# print(t)
# print(t[0])
# print(t[100])

# кортежи поддерижвают срезы [start:stop:step]
# print(t[0:10000])
# print(t[0:])
# t1 = t[:]
# print(id(t1), id(t))
# print(t[-1::-2])


# срезы работаю и для строк и для списков, и для кортежей с одинаковой логикой
# l1 = [0, 1, 2, 3]
# l2 = [4, 5, 6, 7]
# l3 = [8, 9, 10]
#
# l = l1 + l2 + l3
# print(l)
#
# t1 = (1, 2)
# t2 = (3, 4)
# t = t1 + t2
# print(t)

# l1 = [0, 1, 2, 3]
# l2 = [4, 5, 6, 7]
# l3 = [8, 9, 10]
#
# l = [l1, l2, l3]
# print(l)
# l1 = 0
# l1[0] = "TEST"
# print(l)

# print(l, l1)
# l[0][0] = "TEST"
# print(l, l1)

# a = 0
# l1 = [a, 1, 2, 3]
# l2 = [4, 5, 6, 7]
# l3 = [8, 9, 10]
#
# l = [l1, l2, l3]
# a = "TEST"
# print(l1, l)

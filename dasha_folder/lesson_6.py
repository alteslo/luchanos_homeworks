"""ДЗ всё. что не успела (если такое есть)

Грокаем алгоритмы - начинаем читать (до 40 страницы).

Диаграммы Эйлера-Венна (кружочки)

ЗАДАЧА
Есть лист с элементами [1, 2, 3, 4, 5]
Кортеж (2, 3, "test", "ololo", 5, 6)
Множество {5}
Нужно найти общие элементы всех этих коллекций (можешь всзять свои собственные коллекции)

ЗАДАЧА
Запрашиваем у пользака с экрана произвольные элементы и складываем в список. Если пользователь ввел стоп-слово, то
прекращаем формирование списка и выводим его на экран.

ЗАДАЧА
Есть список [1, -100, 10000, 0, 9, 1] (можешь написать свой собственный, только чтобы вс были числами).
Запрашиваем у пользователя число. Нужно вывести:
1. Присутствует ли число в списке
2. Если присутствует, то вывести на каких его позициях оно присутствует
3. Если число отсутствует выводить соответствующее сообщениена

Дорешать задачи из методички (до 6 включительно)

Добавить меня фо френды на https://www.linkedin.com/in/luchanos
"""

# s = set()  # аналог пустого множества
# l = list()  # аналог пустого списка
# t = tuple()  # аналог пустого кортежа
# s1 = str()  # аналог пустой строки

# множество - содержит ТОЛЬКО элементы котрые отосятся к неизменяемому типу данных + все они уникальны + неупорядочены
# l = [1, 1, 1, 1, 1, 2, 2, 2, 3, 2, 4, 5, 1, 2]
# s = {1, 2, 3, 4, 5}   # фигурные скобки - либо множество, либо словарь
# s1 = {1, 100, 10, 'asdfsdfasdfasdf'}
# print(s)
# print(type(s))
# print(list((1, 2, 3, 4, 5)))
# print(list(s))
# t1 = (l, l, l)
# print({t1})
# print(set(l))
# print(s.intersection(s1))

# l1 = [1, 2, 3]
# l2 = [3, 4, 5, 6]
# l3 = l1 + l2
# l1.extend(l2)
# print(l1)
# print(l1, l2)
# print((1, 2, 3) + (3, 4, 5))

# s1 = {1, 2, 3}
# s2 = {3, 4, 5, 6}
# s1.update(s2)
# print(s1)

# s = {100, 50, 1, 60, 99}
# s1 = {100, 50, 200}
# s3 = {100, 60, True}
# l = [1, -100, 10000, 0, 9, True]
# t = (1, -100, 10000, 0, 9, False)

# print(s.intersection(s1).intersection(s3))
# print(sorted(s, reverse=True), s)
# print(sorted(l), l)
# print(sorted(t), t)

# sorted - не меняет исходую коллекцию, а l.sort() - поменяет исходный лист!
# print(l)
# l.sort()
# print(l)

# print(list(reversed(l)))
# print(tuple(reversed(t)))

# reversed - не меняет исходую коллекцию, а l.reverse() - поменяет исходный лист!
# l.reverse()
# print(l)

# s0 = {(1, 2, 3)}
# s0.update(s3)
# s0.add(756)
# print(s0)
# s0.add(756)
# print(s0)

# s3 = {100, 60, True}
# l = [1, -100, 10000, 0, 9, 1]
# t = (1, -100, 10000, 0, 9, False)
#
# # поиск подскроки в строке
# print("abc1" in "abcdefg")
#
# # поиск элемента в коллекции
# print(1 in l)
# print('w' in t)
# print(1 in s3)
# print(True in l)

# d = {"драгоценности": "золото, бриллианты, сапфиры",
#      "наличка": "евро, доллары"}
# d1 = {1: "яблоко"}
# key = input("введите ключ: ")
# print(d[key])

# l = ["Николай", "Свиридов", "Москва", "29"]
# # s = {"Николай", "Свиридов", "Москва", "29"}
# user_1 = {"имя": "Николай", "фамилия": "Свиридов", "город": "Москва", "возраст": "29"}
# user_2 = {"имя": "Дарья", "фамилия": "Мишанкова", "город": "Москва", "возраст": "28"}
# users = [user_1, user_2]
#
# print(user_1)
# print(user_2)

# цикл for
# l = ["Николай", "Свиридов", "Москва", "29"]

# cnt = 0
# while cnt < len(l):
#     print(l[cnt])
#     cnt += 1

# for list_element in l:
#     buf = list_element.upper()
#     print(buf)

# s = {"Николай", "Свиридов", "Москва", "29"}
#
# for list_element in s:
#     buf = list_element.upper()
#     print(buf)

user_1 = {"имя": "Николай", "фамилия": "Свиридов", "город": "Москва", "возраст": "29"}
user_2 = {"имя": "Дарья", "фамилия": "Мишанкова", "город": "Москва", "возраст": "28"}
user_list = [user_1, user_2]

# for el in user_1:
#     print(el)

# items = user_1.items()
# print(items)

# for item in items:
#     print(item[1])

# for user in user_list:
#     print(user["фамилия"])

# print(user_1.keys())
# print(user_1.values())
